<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>IndexedDB Message Storage</title>
	</head>
	<body>
		<div id="status">Initializing...</div>
		<script>
			const DB_NAME = 'messagesDB';
			const STORE_NAME = 'messages';
			const VERSION = 1;

			// Function to generate random string
			function generateRandomString(length) {
				return Math.random()
					.toString(36)
					.substring(2, length + 2);
			}

			// Function to generate random number
			function generateRandomNumber(min, max) {
				return Math.floor(Math.random() * (max - min + 1)) + min;
			}

			// Function to generate random email recipient
			function generateEmailRecipient() {
				return {
					name: `User ${generateRandomString(8)}`,
					address: `${generateRandomString(8)}@example.com`,
				};
			}

			// Function to generate a unique message
			function generateMessage(id) {
				return {
					id: id.toString(),
					threadId: generateRandomString(16),
					userAccount: generateRandomNumber(1, 1000),
					date: Date.now() - generateRandomNumber(0, 365 * 24 * 60 * 60 * 1000),
					size: generateRandomNumber(1000, 1000000),
					p2Helper: generateRandomString(32),
					folder: generateRandomNumber(1, 10),
					tags: Array.from({ length: generateRandomNumber(0, 5) }, () =>
						generateRandomNumber(1, 20)
					),
					gmailSplit: Math.random() > 0.5 ? generateRandomNumber(1, 100) : null,
					internalSplit: Math.random() > 0.5 ? generateRandomNumber(1, 100) : null,
					canUnsubscribe: Math.random() > 0.5,
					hasAttachments: Math.random() > 0.5,
					isDraft: Math.random() > 0.5,
					isImportant: Math.random() > 0.5,
					isSent: Math.random() > 0.5,
					isStarred: Math.random() > 0.5,
					isUnread: Math.random() > 0.5,
					sender: [generateEmailRecipient()],
					recipients: {
						to: Array.from({ length: generateRandomNumber(1, 3) }, generateEmailRecipient),
						cc: Array.from({ length: generateRandomNumber(0, 2) }, generateEmailRecipient),
						bcc: Array.from({ length: generateRandomNumber(0, 2) }, generateEmailRecipient),
					},
					refs: {
						rfc822MsgId: Math.random() > 0.5 ? generateRandomString(32) : null,
						inReplyTo: Math.random() > 0.5 ? generateRandomString(32) : null,
						draftId: Math.random() > 0.5 ? generateRandomString(32) : null,
					},
				};
			}

			// Function to open database
			function openDatabase() {
				return new Promise((resolve, reject) => {
					const request = indexedDB.open(DB_NAME, VERSION);

					request.onerror = () => reject(request.error);
					request.onsuccess = () => resolve(request.result);

					request.onupgradeneeded = (event) => {
						const db = event.target.result;
						if (!db.objectStoreNames.contains(STORE_NAME)) {
							const store = db.createObjectStore(STORE_NAME, { keyPath: 'id' });
							store.createIndex('threadId', 'threadId', { unique: false });
							store.createIndex('userAccount', 'userAccount', { unique: false });
							store.createIndex('date', 'date', { unique: false });
						}
					};
				});
			}

			// Function to insert messages in batches
			async function insertMessages(db, totalMessages = 1000000, batchSize = 10000) {
				const statusElement = document.getElementById('status');
				let inserted = 0;

				while (inserted < totalMessages) {
					const batch = [];
					const batchEnd = Math.min(inserted + batchSize, totalMessages);

					for (let i = inserted; i < batchEnd; i++) {
						batch.push(generateMessage(i));
					}

					await new Promise((resolve, reject) => {
						const transaction = db.transaction(STORE_NAME, 'readwrite');
						const store = transaction.objectStore(STORE_NAME);

						batch.forEach((message) => {
							store.add(message);
						});

						transaction.oncomplete = () => {
							inserted = batchEnd;
							statusElement.textContent = `Inserted ${inserted} of ${totalMessages} messages...`;
							resolve();
						};

						transaction.onerror = () => reject(transaction.error);
					});
				}
			}

			// Main function to initialize and populate the database
			async function initializeDatabase() {
				try {
					const db = await openDatabase();
					// await insertMessages(db, 100, 100);
					document.getElementById('status').textContent = 'Database populated successfully!';
				} catch (error) {
					console.error('Error:', error);
					document.getElementById('status').textContent = `Error: ${error.message}`;
				}
			}

			// Start the process
			initializeDatabase();
		</script>
	</body>
</html>
